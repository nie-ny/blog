<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>å­¦ä¹ </title>
  </head>
  <body>
    <canvas id="c3d" class="c2d" width="1200" height="800"></canvas>
    <script type="module">
      import * as THREE from '../three.js-dev/build/three.module.js'
      import { OrbitControls } from '../three.js-dev/examples/jsm/controls/OrbitControls.js'

      const Dom = document.querySelector('#c3d')
      const width = Dom.clientWidth
      const height = Dom.clientHeight

      // çº¹ç†åŠ è½½å™¨
      const loader = new THREE.TextureLoader()

      // æ¸²æŸ“å™¨
      let renderer
      // ç›¸æœº
      let camera
      // åœºæ™¯
      let scene
      // ç¯å…‰
      let light
      // ç›¸æœºæ§åˆ¶
      let controls

      /**
       * åˆå§‹åŒ–æ¸²æŸ“å™¨
       * */
      function initRenderer() {
        // antialias: true, alpha: true æŠ—é”¯é½¿è®¾ç½®
        renderer = new THREE.WebGLRenderer({ canvas: Dom, antialias: true, alpha: true })
        // window.devicePixelRatio è®¾å¤‡åƒç´ æ¯”
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(width, height)
        // Dom.appendChild(renderer.domElement)
      }

      /**
       * åˆå§‹åŒ–ç›¸æœº
       */
      function initCamera() {
        camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000)
        camera.position.set(5, -20, 200)
        camera.lookAt(0, 3, 0)
        window.camera = camera
      }
      /**
       * åˆå§‹åŒ–åœºæ™¯
       */
      function initScene() {
        scene = new THREE.Scene()
        scene.background = new THREE.Color(0x020924)
        // é›¾
        // scene.fog = new THREE.Fog(0x020924, 200, 1000)
        window.scene = scene
      }

      /**
       * åˆå§‹åŒ– ç›¸æœºæ§åˆ¶
       */
      function initControls() {
        controls = new OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.enableZoom = true
        controls.autoRotate = false
        controls.autoRotateSpeed = 2
        controls.enablePan = true
      }

      /**
       * åˆå§‹åŒ–å…‰
       */
      function initLight() {
        // ç¯å¢ƒå…‰
        // const ambientLight = new THREE.AmbientLight(0xcccccc, 1.1)
        // scene.add(ambientLight)
        // å¹³è¡Œå…‰
        let directionalLight = new THREE.DirectionalLight(0xffffff, 0.2)
        directionalLight.position.set(1, 0.1, 0).normalize()
        // å¹³è¡Œå…‰2
        let directionalLight2 = new THREE.DirectionalLight(0xff2ffff, 0.2)
        directionalLight2.position.set(1, 0.1, 0.1).normalize()
        scene.add(directionalLight)
        scene.add(directionalLight2)
        // åŠçƒå…‰
        let hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.2)
        hemiLight.position.set(0, 1, 0)
        scene.add(hemiLight)
        // å¹³è¡Œå…‰3
        let directionalLight3 = new THREE.DirectionalLight(0xffffff)
        directionalLight3.position.set(1, 500, -20)
        // å¼€å¯é˜´å½±
        directionalLight3.castShadow = true
        // è®¾ç½®å…‰è¾¹ç•Œ
        directionalLight3.shadow.camera.top = 18
        directionalLight3.shadow.camera.bottom = -10
        directionalLight3.shadow.camera.left = -52
        directionalLight3.shadow.camera.right = 12
        scene.add(directionalLight3)
      }

      // æ—‹è½¬é˜Ÿåˆ—
      const rotateArr = []
      const rotateSlowArr = []
      // æ”¾å¤§å¹¶é€æ˜ é˜Ÿåˆ—
      const bigByOpacityArr = []
      // ç§»åŠ¨ é˜Ÿåˆ—
      const moveArr = []

      // è¾¹ç•Œ ç»˜åˆ¶ç‚¹é›†åˆ
      const lines = []
      // ç‚«å…‰ç²’å­ å‡ ä½•ä½“
      const geometryLz = new THREE.BufferGeometry()
      // ç‚«å…‰ç²’å­ é€æ˜åº¦
      let opacitys = []
      /**
       * æ¸²æŸ“å‡½æ•°
       * */
      function renders(time) {
        time *= 0.003
        // 3Då¯¹è±¡ æ—‹è½¬
        rotateArr.forEach((obj) => {
          obj.rotation.y = time
        })
        rotateSlowArr.forEach((obj) => {
          // obj.rotation.y = obj._y + time * 0.1
        })

        bigByOpacityArr.forEach(function (mesh) {
          //  ç›®æ ‡ åœ†ç¯æ”¾å¤§ å¹¶ é€æ˜
          mesh._s += 0.01
          mesh.scale.set(1 * mesh._s, 1 * mesh._s, 1 * mesh._s)
          if (mesh._s <= 2) {
            mesh.material.opacity = 2 - mesh._s
          } else {
            mesh._s = 1
          }
        })

        moveArr.forEach(function (mesh) {
          mesh._s += 0.01
          let tankPosition = new THREE.Vector3()
          tankPosition = mesh.curve.getPointAt(mesh._s % 1)
          mesh.position.set(tankPosition.x, tankPosition.y, tankPosition.z)
        })

        if (geometryLz.attributes.position) {
          geometryLz.currentPos += geometryLz.pointSpeed
          for (let i = 0; i < geometryLz.pointSpeed; i++) {
            opacitys[(geometryLz.currentPos - i) % lines.length] = 0
          }

          for (let i = 0; i < 200; i++) {
            opacitys[(geometryLz.currentPos + i) % lines.length] = i / 50 > 2 ? 2 : i / 50
          }
          geometryLz.attributes.aOpacity.needsUpdate = true
        }

        renderer.clear()
        renderer.render(scene, camera)
      }
      /**
       * åŠ¨ç”»æ¸²æŸ“å‡½æ•°
       */
      function animate() {
        window.requestAnimationFrame((time) => {
          if (controls) controls.update()

          renders(time)
          animate()
        })
      }

      /**
       * èƒŒæ™¯ç»˜åˆ¶
       * */
      function bg() {
        const positions = []
        const colors = []
        // åˆ›å»º å‡ ä½•ä½“
        const geometry = new THREE.BufferGeometry()
        for (let i = 0; i < 10000; i++) {
          let vertex = new THREE.Vector3()
          vertex.x = Math.random() * 2 - 1
          vertex.y = Math.random() * 2 - 1
          vertex.z = Math.random() * 2 - 1
          positions.push(vertex.x, vertex.y, vertex.z)
          // let color = new THREE.Color()
          // color.setHSL(Math.random() * 0.2 + 0.5, 0.55, Math.random() * 0.25 + 0.55)
          // colors.push(color.r, color.g, color.b)
        }
        // å¯¹å‡ ä½•ä½“ è®¾ç½® åæ ‡ å’Œ é¢œè‰²
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3))
        // geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3))
        // é»˜è®¤çƒä½“
        geometry.computeBoundingSphere()

        // ------------- 1 ----------
        // æ˜Ÿæ˜Ÿèµ„æºå›¾ç‰‡
        // ParticleBasicMaterial ç‚¹åŸºç¡€æè´¨
        var starsMaterial = new THREE.ParticleBasicMaterial({
          map: generateSprite(),
          size: 2,
          transparent: true,
          opacity: 1,
          //trueï¼šä¸”è¯¥å‡ ä½•ä½“çš„colorså±æ€§æœ‰å€¼ï¼Œåˆ™è¯¥ç²’å­ä¼šèˆå¼ƒç¬¬ä¸€ä¸ªå±æ€§--colorï¼Œè€Œåº”ç”¨è¯¥å‡ ä½•ä½“çš„colorså±æ€§çš„é¢œè‰²
          // vertexColors: true,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: true
        })
        // ç²’å­ç³»ç»Ÿ ç½‘æ ¼
        let stars = new THREE.ParticleSystem(geometry, starsMaterial)
        stars.scale.set(300, 300, 300)
        scene.add(stars)

        // ------------- 2 ----------
        // PointsMaterial ç‚¹æè´¨
        // let material = new THREE.PointsMaterial({ size: 1, vertexColors: THREE.VertexColors })
        // Points ç‚¹ç½‘æ ¼
        // let particleSystem = new THREE.Points(geometry, material)
        // particleSystem.scale.set(300, 300, 300)
        // scene.add(particleSystem)
      }

      /**
       * åˆ›å»º æ–¹å½¢çº¹ç†
       * */
      function generateSprite() {
        const canvas = document.createElement('canvas')
        canvas.width = 16
        canvas.height = 16

        const context = canvas.getContext('2d')
        // åˆ›å»ºé¢œè‰²æ¸å˜
        const gradient = context.createRadialGradient(
          canvas.width / 2,
          canvas.height / 2,
          0,
          canvas.width / 2,
          canvas.height / 2,
          canvas.width / 2
        )
        gradient.addColorStop(0, 'rgba(255,255,255,1)')
        gradient.addColorStop(0.2, 'rgba(0,255,255,1)')
        gradient.addColorStop(0.4, 'rgba(0,0,64,1)')
        gradient.addColorStop(1, 'rgba(0,0,0,1)')

        // ç»˜åˆ¶æ–¹å½¢
        context.fillStyle = gradient
        context.fillRect(0, 0, canvas.width, canvas.height)
        // è½¬ä¸ºçº¹ç†
        const texture = new THREE.Texture(canvas)
        texture.needsUpdate = true
        return texture
      }

      // åœ°çƒï¼Œæœˆäº® 3Då±‚
      const landOrbitObject = new THREE.Object3D()
      // åœ°çƒ3Då±‚
      const earthObject = new THREE.Object3D()

      // åœ°çƒåŠå¾„
      const globeRadius = 5
      /**
       * çƒç›¸å…³åŠ è½½
       * */
      function earth() {
        const radius = globeRadius
        const widthSegments = 100
        const heightSegments = 100
        const sphereGeometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments)

        // åœ°çƒ
        const earthTexture = loader.load('./3.jpg')
        const earthMaterial = new THREE.MeshStandardMaterial({
          map: earthTexture
        })
        const earthMesh = new THREE.Mesh(sphereGeometry, earthMaterial)

        // æœˆçƒ
        const moonTexture = loader.load('./2.jpg')
        const moonMaterial = new THREE.MeshPhongMaterial({ map: moonTexture })
        const moonMesh = new THREE.Mesh(sphereGeometry, moonMaterial)
        moonMesh.scale.set(0.1, 0.1, 0.1)
        moonMesh.position.x = 10

        // æœˆäº®3Då±‚
        const moonObject = new THREE.Object3D()
        moonObject.add(moonMesh)
        // åŠ å…¥åŠ¨ç”»é˜Ÿåˆ—
        rotateArr.push(moonObject)

        // åœ°çƒåŠ å…¥ åœ°çƒ3Då±‚
        earthObject.add(earthMesh)
        earthObject.rotation.set(0.5, 2.9, 0.1)
        earthObject._y = 2.0
        // åŠ å…¥åŠ¨ç”»é˜Ÿåˆ—
        rotateSlowArr.push(earthObject)

        // åŠ å…¥ åœ°çƒ3Då±‚
        landOrbitObject.add(earthObject)
        // åŠ å…¥ æœˆäº®3Då±‚
        landOrbitObject.add(moonObject)

        scene.add(landOrbitObject)
      }

      /**
       * ç»ç»´åº¦ è½¬æ¢åæ ‡
       * THREE.Spherical çƒç±»åæ ‡
       * lng:ç»åº¦
       * lat:ç»´åº¦
       * radius:åœ°çƒåŠå¾„
       */
      function lglt2xyz(lng, lat, radius) {
        // ä»¥zè½´æ­£æ–¹å‘ä¸ºèµ·ç‚¹çš„æ°´å¹³æ–¹å‘å¼§åº¦å€¼
        const theta = (90 + lng) * (Math.PI / 180)
        // ä»¥yè½´æ­£æ–¹å‘ä¸ºèµ·ç‚¹çš„å‚ç›´æ–¹å‘å¼§åº¦å€¼
        const phi = (90 - lat) * (Math.PI / 180)

        return new THREE.Vector3().setFromSpherical(new THREE.Spherical(radius, phi, theta))
      }

      /**
       * ç”»å›¾
       * */
      function drawChart() {
        let markPos = lglt2xyz(106.553091, 29.57337, 5)
        // ç›®æ ‡ç‚¹
        spotCircle([markPos.x, markPos.y, markPos.z])

        lineConnect([121.48, 31.23], [116.4, 39.91])
        lineConnect([121.48, 31.23], [121.564136, 25.071558])
        lineConnect([121.48, 31.23], [104.896185, 11.598253])
        lineConnect([121.48, 31.23], [130.376441, -16.480708])
        lineConnect([121.48, 31.23], [-71.940328, -13.5304])
        lineConnect([121.48, 31.23], [-3.715707, 40.432926])
      }

      /**
       * ç»˜åˆ¶ ç›®æ ‡ç‚¹
       * */
      function spotCircle(spot) {
        // åœ†
        const geometry1 = new THREE.CircleGeometry(0.02, 100)
        const material1 = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide })
        const circle = new THREE.Mesh(geometry1, material1)
        circle.position.set(spot[0], spot[1], spot[2])
        // meshåœ¨çƒé¢ä¸Šçš„æ³•çº¿æ–¹å‘(çƒå¿ƒå’Œçƒé¢åæ ‡æ„æˆçš„æ–¹å‘å‘é‡)
        var coordVec3 = new THREE.Vector3(spot[0], spot[1], spot[2]).normalize()
        // meshé»˜è®¤åœ¨XOYå¹³é¢ä¸Šï¼Œæ³•çº¿æ–¹å‘æ²¿ç€zè½´new THREE.Vector3(0, 0, 1)
        var meshNormal = new THREE.Vector3(0, 0, 1)
        // å››å…ƒæ•°å±æ€§.quaternionè¡¨ç¤ºmeshçš„è§’åº¦çŠ¶æ€
        //.setFromUnitVectors();è®¡ç®—ä¸¤ä¸ªå‘é‡ä¹‹é—´æ„æˆçš„å››å…ƒæ•°å€¼
        circle.quaternion.setFromUnitVectors(meshNormal, coordVec3)
        earthObject.add(circle)

        // åœ†ç¯
        const geometry2 = new THREE.RingGeometry(0.03, 0.04, 100)
        // transparent è®¾ç½® true å¼€å¯é€æ˜
        const material2 = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide, transparent: true })
        const circleY = new THREE.Mesh(geometry2, material2)
        circleY.position.set(spot[0], spot[1], spot[2])

        // // meshåœ¨çƒé¢ä¸Šçš„æ³•çº¿æ–¹å‘(çƒå¿ƒå’Œçƒé¢åæ ‡æ„æˆçš„æ–¹å‘å‘é‡)
        // var coordVec3 = new THREE.Vector3(spot[0], spot[1], spot[2]).normalize()
        // // meshé»˜è®¤åœ¨XOYå¹³é¢ä¸Šï¼Œæ³•çº¿æ–¹å‘æ²¿ç€zè½´new THREE.Vector3(0, 0, 1)
        // var meshNormal = new THREE.Vector3(0, 0, 1)
        // // å››å…ƒæ•°å±æ€§.quaternionè¡¨ç¤ºmeshçš„è§’åº¦çŠ¶æ€
        // //.setFromUnitVectors();è®¡ç®—ä¸¤ä¸ªå‘é‡ä¹‹é—´æ„æˆçš„å››å…ƒæ•°å€¼
        // circleY.quaternion.setFromUnitVectors(meshNormal, coordVec3)
        // æŒ‡å‘åœ†å¿ƒ
        circleY.lookAt(new THREE.Vector3(0, 0, 0))
        earthObject.add(circleY)
        // åŠ å…¥åŠ¨ç”»é˜Ÿåˆ—
        bigByOpacityArr.push(circleY)
      }

      /**
       * ç»˜åˆ¶ ä¸¤ä¸ªç›®æ ‡ç‚¹å¹¶è¿çº¿
       * */
      function lineConnect(posStart, posEnd) {
        const v0 = lglt2xyz(posStart[0], posStart[1], globeRadius)
        const v3 = lglt2xyz(posEnd[0], posEnd[1], globeRadius)

        const angle = v0.angleTo(v3)
        let vtop = v0.clone().add(v3)
        vtop = vtop.normalize().multiplyScalar(globeRadius)

        let n
        if (angle <= 1) {
          n = (globeRadius / 5) * angle
        } else if (angle > 1 && angle < 2) {
          n = (globeRadius / 5) * Math.pow(angle, 2)
        } else {
          n = (globeRadius / 5) * Math.pow(angle, 1.5)
        }

        const v1 = v0
          .clone()
          .add(vtop)
          .normalize()
          .multiplyScalar(globeRadius + n)
        const v2 = v3
          .clone()
          .add(vtop)
          .normalize()
          .multiplyScalar(globeRadius + n)
        // ä¸‰ç»´ä¸‰æ¬¡è´å¡å°”æ›²çº¿(v0èµ·ç‚¹ï¼Œv1ç¬¬ä¸€ä¸ªæ§åˆ¶ç‚¹ï¼Œv2ç¬¬äºŒä¸ªæ§åˆ¶ç‚¹ï¼Œv3ç»ˆç‚¹)
        const curve = new THREE.CubicBezierCurve3(v0, v1, v2, v3)

        // ç»˜åˆ¶ ç›®æ ‡ä½ç½®
        spotCircle([v0.x, v0.y, v0.z])
        spotCircle([v3.x, v3.y, v3.z])
        moveSpot(curve)

        const lineGeometry = new THREE.BufferGeometry()
        // è·å–æ›²çº¿ ä¸Šçš„50ä¸ªç‚¹
        var points = curve.getPoints(50)
        var positions = []
        var colors = []
        var color = new THREE.Color()

        // ç»™æ¯ä¸ªé¡¶ç‚¹è®¾ç½®æ¼”ç¤º å®ç°æ¸å˜
        for (var j = 0; j < points.length; j++) {
          color.setHSL(0.81666 + j, 0.88, 0.715 + j * 0.0025) // ç²‰è‰²
          colors.push(color.r, color.g, color.b)
          positions.push(points[j].x, points[j].y, points[j].z)
        }
        // æ”¾å…¥é¡¶ç‚¹ å’Œ è®¾ç½®é¡¶ç‚¹é¢œè‰²
        lineGeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3, true))
        lineGeometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3, true))

        const material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors, side: THREE.DoubleSide })
        const line = new THREE.Line(lineGeometry, material)

        earthObject.add(line)
      }

      /**
       * çº¿ä¸Šç§»åŠ¨ç‰©ä½“
       * */
      function moveSpot(curve) {
        // çº¿ä¸Šçš„ç§»åŠ¨ç‰©ä½“
        const aGeo = new THREE.SphereGeometry(0.04, 0.04, 0.04)
        const aMater = new THREE.MeshPhongMaterial({ color: 0xff0000, side: THREE.DoubleSide })
        const aMesh = new THREE.Mesh(aGeo, aMater)
        // ä¿å­˜æ›²çº¿å®ä¾‹
        aMesh.curve = curve
        aMesh._s = 0

        moveArr.push(aMesh)
        earthObject.add(aMesh)
      }

      /**
       * å®šä¹‰ ç€è‰²å™¨
       **/
      const vertexShader = `
                            attribute float aOpacity;
                            uniform float uSize;
                            varying float vOpacity;

                            void main(){
                                gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0);
                                gl_PointSize = uSize;

                                vOpacity=aOpacity;
                            }
                            `
      const fragmentShader = `
                      varying float vOpacity;
                      uniform vec3 uColor;

                      float invert(float n){
                          return 1.-n;
                      }

                      void main(){
                        if(vOpacity <=0.2){
                            discard;
                        }
                        vec2 uv=vec2(gl_PointCoord.x,invert(gl_PointCoord.y));
                        vec2 cUv=2.*uv-1.;
                        vec4 color=vec4(1./length(cUv));
                        color*=vOpacity;
                        color.rgb*=uColor;

                        gl_FragColor=color;
                      }
                      `

      /**
       * è¾¹ç•Œç‚«å…‰è·¯å¾„
       * */
      function dazzleLight() {
        const loader = new THREE.FileLoader()
        loader.load('./100000.json', (data) => {
          const jsondata = JSON.parse(data)
          console.log('ğŸš€ ~ file: index.html:454 ~ loader.load ~ jsondata:', jsondata)

          // ä¸­å›½è¾¹ç•Œ
          const feature = jsondata.features[0]
          const province = new THREE.Object3D()
          province.properties = feature.properties.name
          // ç‚¹æ•°æ®
          const coordinates = feature.geometry.coordinates

          coordinates.forEach((coordinate) => {
            // coordinate å¤šè¾¹å½¢æ•°æ®
            coordinate.forEach((rows) => {
              // ç»˜åˆ¶çº¿
              const line = lineDraw(rows, 0xaa381e)
              province.add(line)
            })
          })
          // æ·»åŠ åœ°å›¾è¾¹ç•Œ
          earthObject.add(province)

          // æ‹‰å¹³ ä¸ºä¸€ç»´æ•°ç»„
          const positions = new Float32Array(lines.flat(1))
          // è®¾ç½®é¡¶ç‚¹
          geometryLz.setAttribute('position', new THREE.BufferAttribute(positions, 3))
          // è®¾ç½® ç²’å­é€æ˜åº¦ä¸º 0
          opacitys = new Float32Array(positions.length).map(() => 0)
          geometryLz.setAttribute('aOpacity', new THREE.BufferAttribute(opacitys, 1))

          geometryLz.currentPos = 0
          // ç‚«å…‰ç§»åŠ¨é€Ÿåº¦
          geometryLz.pointSpeed = 20

          // æ§åˆ¶ é¢œè‰²å’Œç²’å­å¤§å°
          const params = {
            pointSize: 2.0,
            pointColor: '#4ec0e9'
          }

          // åˆ›å»ºç€è‰²å™¨æè´¨
          const material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true, // è®¾ç½®é€æ˜
            uniforms: {
              uSize: {
                value: params.pointSize
              },
              uColor: {
                value: new THREE.Color(params.pointColor)
              }
            }
          })
          const points = new THREE.Points(geometryLz, material)

          earthObject.add(points)
        })
      }

      /**
       * è¾¹æ¡† å›¾å½¢ç»˜åˆ¶
       * @param polygon å¤šè¾¹å½¢ ç‚¹æ•°ç»„
       * @param color æè´¨é¢œè‰²
       * */
      let indexBol = true
      function lineDraw(polygon, color) {
        const lineGeometry = new THREE.BufferGeometry()
        const pointsArray = new Array()
        polygon.forEach((row) => {
          // è½¬æ¢åæ ‡
          const xyz = lglt2xyz(row[0], row[1], globeRadius)
          // åˆ›å»ºä¸‰ç»´ç‚¹
          pointsArray.push(xyz)

          if (indexBol) {
            // ä¸ºäº†å¥½çœ‹ è¿™é‡Œåªè¦å†…é™†è¾¹ç•Œ
            lines.push([xyz.x, xyz.y, xyz.z])
          }
        })

        indexBol = false

        // æ”¾å…¥å¤šä¸ªç‚¹
        lineGeometry.setFromPoints(pointsArray)

        const lineMaterial = new THREE.LineBasicMaterial({
          color: color
        })
        return new THREE.Line(lineGeometry, lineMaterial)
      }

      window.onload = () => {
        // åˆå§‹åŒ–
        initRenderer()
        initCamera()
        initScene()
        initLight()
        initControls()

        // ç»˜åˆ¶
        bg()
        earth()
        drawChart()
        dazzleLight()

        // æ¸²æŸ“
        animate()
      }
    </script>
  </body>
</html>
