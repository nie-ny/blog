<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>å­¦ä¹ </title>
    <style>
      #tooltip {
        position: absolute;
        z-index: 2;
        background: white;
        padding: 10px;
        border-radius: 2px;
        visibility: hidden;
      }
    </style>
  </head>
  <body>
    <canvas id="c2d" class="c2d" width="1000" height="500"></canvas>

    <div id="tooltip"></div>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script type="module">
      import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/build/three.module.js'
      import { OrbitControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/controls/OrbitControls.js'

      // ä»¥åŒ—äº¬ä¸ºä¸­å¿ƒ ä¿®æ”¹åæ ‡
      const projection = d3.geoMercator().center([116.412318, 39.909843]).translate([0, 0])

      const canvas = document.querySelector('#c2d')
      // æ¸²æŸ“å™¨
      const renderer = new THREE.WebGLRenderer({ canvas })

      const fov = 75 // è§†é‡èŒƒå›´
      const aspect = 2 // ç›¸æœºé»˜è®¤å€¼ ç”»å¸ƒçš„å®½é«˜æ¯”
      const near = 0.1 // è¿‘å¹³é¢
      const far = 1000 // è¿œå¹³é¢
      // é€è§†æŠ•å½±ç›¸æœº
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far)

      // ç›¸æœºä½ç½®
      camera.position.set(0, 0, 170)
      camera.up.set(0, 1, 0)

      // window.addEventListener('keydown', onKeyDown, false)
      // const distance = 1
      // function onKeyDown() {
      //   switch (event.keyCode) {
      //     case 87:
      //       camera.translateY(-distance)
      //       break
      //     case 83:
      //       camera.translateY(distance)
      //       break
      //     case 65:
      //       camera.translateX(-distance)
      //       break
      //     case 68:
      //       camera.translateX(distance)
      //   }
      // }

      // æ§åˆ¶ç›¸æœº
      const controls = new OrbitControls(camera, canvas)
      controls.update()

      // åˆ›å»ºåœºæ™¯
      const scene = new THREE.Scene()

      // var axes = new THREE.AxisHelper(700)
      // scene.add(axes)

      const color = 0xffffff
      const intensity = 3
      // åˆ›å»ºå…‰æº
      const light = new THREE.AmbientLight(color, intensity)
      // å…‰æº åŠ å…¥åœºæ™¯
      scene.add(light)
      //

      const loader = new THREE.FileLoader()
      loader.load('https://geo.datav.aliyun.com/areas_v3/bound/100000_full.json', (data) => {
        const jsondata = JSON.parse(data)
        // console.log('ğŸš€ ~ file: ç»˜åˆ¶åœ°å›¾.html ~ line 42 ~ loader.load ~ jsondata', jsondata)
        generateGeometry(jsondata)
      })

      const map = new THREE.Object3D()
      function generateGeometry(jsondata) {
        // å…¨å›½ä¿¡æ¯
        const features = jsondata.features

        features.forEach((feature) => {
          // å•ä¸ªåŸå¸‚ ç»çº¬åº¦
          const province = new THREE.Object3D()
          // åœ°å€
          province.properties = feature.properties.name

          const coordinates = feature.geometry.coordinates

          const color = ['é‡åº†å¸‚', 'ä¸Šæµ·å¸‚'].includes(feature.properties.name) ? 'blue' : 'yellow'

          if (feature.geometry.type === 'MultiPolygon') {
            // å¤šè¾¹å½¢
            coordinates.forEach((coordinate) => {
              coordinate.forEach((rows) => {
                //
                const line = lineDraw(rows)
                const mesh = drawExtrudeMesh(rows, color)
                mesh.diTu = true

                province.add(line)
                province.add(mesh)
              })
            })
          }

          if (feature.geometry.type === 'Polygon') {
            coordinates.forEach((coordinate) => {
              const line = lineDraw(coordinate)
              const mesh = drawExtrudeMesh(coordinate, color)
              mesh.diTu = true

              province.add(line)
              province.add(mesh)
            })
          }

          map.add(province)
        })

        scene.add(map)
      }

      /**
       * ç”»çº¿
       * */
      function lineDraw(polygon) {
        const lineGeometry = new THREE.BufferGeometry()
        const pointsArray = new Array()
        polygon.forEach((row) => {
          const [x, y] = projection(row)
          pointsArray.push(new THREE.Vector3(x, -y, 9))
        })
        lineGeometry.setFromPoints(pointsArray)

        const lineMaterial = new THREE.LineBasicMaterial({
          color: 'yellow'
        })
        return new THREE.Line(lineGeometry, lineMaterial)
      }

      /**
       * å›¾è¡Œ
       * */
      function drawExtrudeMesh(polygon, color) {
        const shape = new THREE.Shape()
        polygon.forEach((row, i) => {
          const [x, y] = projection(row)

          if (i === 0) {
            shape.moveTo(x, -y)
          }

          shape.lineTo(x, -y)
        })

        const geometry = new THREE.ExtrudeGeometry(shape, {
          depth: 10,
          bevelEnabled: false
        })

        const material = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.5
        })

        return new THREE.Mesh(geometry, material)
      }
      //

      {
        // ä¸¤åœ° è¿çº¿

        let beijingPosition = projection([106.557691, 29.559296])
        let shanghaiPosition = projection([121.495721, 31.236797])
        const [x0, y0, z0] = [...beijingPosition, -10]
        const [x1, y1, z1] = [...shanghaiPosition, -10]

        // ç”¨æ¥ä»£è¡¨æ‰€æœ‰å‡ ä½•ä½“çš„ä¸€ç§æ–¹å¼ -è‡ªå®šä¹‰å‡ ä½•æ•°æ®
        const lineGeometry = new THREE.BufferGeometry()
        lineGeometry.name = 'è¿çº¿'
        lineGeometry.setFromPoints(
          new THREE.QuadraticBezierCurve3(
            new THREE.Vector3(-x0, -y0, z0),
            new THREE.Vector3(-(x0 + x1) / 2, -(y0 + y1) / 2, -20),
            new THREE.Vector3(-x1, -y1, z1)
          ).getPoints()
        )

        // const pointsArray = new Array()
        // pointsArray.push(new THREE.Vector3(-beijingPosition[0], beijingPosition[1], 0))
        // pointsArray.push(new THREE.Vector3(-shanghaiPosition[0], shanghaiPosition[1], 0))

        // lineGeometry.setFromPoints(pointsArray)

        const material = new THREE.LineBasicMaterial({ color: 'white' })

        const line = new THREE.Line(lineGeometry, material)
        line.rotation.y = Math.PI

        scene.add(line)
      }

      window.addEventListener('click', onRay)

      let pickPosition = { x: 0, y: 0 }
      const tooltip = document.getElementById('tooltip')

      // è®¡ç®—å ä»¥ç”»å¸ƒ å¼€å§‹ä¸º ï¼ˆ0ï¼Œ0ï¼‰ç‚¹
      function getCanvasRelativePosition(event) {
        const rect = canvas.getBoundingClientRect()

        tooltip.style.left = event.clientX + 2 + 'px'
        tooltip.style.top = event.clientY + 2 + 'px'

        return {
          x: ((event.clientX - rect.left) * canvas.width) / rect.width,
          y: ((event.clientY - rect.top) * canvas.height) / rect.height
        }
      }

      let lastPick = null
      /**
       * è·å–é¼ æ ‡åœ¨three.js ä¸­å½’ä¸€åŒ–åæ ‡
       * */
      function setPickPosition(event) {
        // è®¡ç®—å ä»¥ç”»å¸ƒ å¼€å§‹ä¸º ï¼ˆ0ï¼Œ0ï¼‰ç‚¹
        const pos = getCanvasRelativePosition(event)

        // æ•°æ®å½’ä¸€åŒ–
        pickPosition.x = (pos.x / canvas.width) * 2 - 1
        pickPosition.y = (pos.y / canvas.height) * -2 + 1 // note we flip Y
      }

      function onRay(event) {
        setPickPosition(event)

        const raycaster = new THREE.Raycaster()
        raycaster.setFromCamera(pickPosition, camera)

        // è®¡ç®—ç‰©ä½“å’Œå°„çº¿çš„äº¤ç‚¹
        const intersects = raycaster.intersectObjects(scene.children, true)

        if (intersects.length > 0) {
          if (intersects[0].object.diTu) {
            if (lastPick) {
              lastPick.object.material.color.set('yellow')
            }

            lastPick = intersects[0]
            // æ˜¯åœ°å›¾å±æ€§
            intersects[0].object.material.color.set(0xff0000)
            // console.log('ğŸš€ ~ file: ç»˜åˆ¶åœ°å›¾.html ~ line 265 ~ onRay ~ intersects[0].object', intersects[0].object)

            tooltip.textContent = intersects[0].object.parent.properties
            tooltip.style.visibility = 'visible'
          } else {
            tooltip.style.visibility = 'hidden'
          }
          // console.log('ğŸš€ ~ file: ç»˜åˆ¶åœ°å›¾.html ~ line 216 ~ onRay ~ intersects', intersects)
        } else {
          tooltip.style.visibility = 'hidden'
        }
      }

      //
      function render(time) {
        time *= 0.001

        // onRay()

        if (resizeRendererToDisplaySize(renderer)) {
          // ç”»å¸ƒå¤§å°ä¿®æ”¹å è°ƒæ•´ æ¯”ä¾‹
          const canvas = renderer.domElement
          camera.aspect = canvas.clientWidth / canvas.clientHeight
          camera.updateProjectionMatrix()
        }

        // åŠ è½½æ¸²æŸ“å™¨
        renderer.render(scene, camera)

        // å¼€å§‹åŠ¨ç”»
        requestAnimationFrame(render)
      }

      // æ¸²æŸ“å™¨ é‡æ–°è°ƒæ•´
      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement
        const width = canvas.clientWidth
        const height = canvas.clientHeight
        const needResize = canvas.width !== width || canvas.height !== height
        if (needResize) {
          renderer.setSize(width, height, false)
        }
        return needResize
      }

      // å¼€å§‹æ¸²æŸ“
      requestAnimationFrame(render)
    </script>
  </body>
</html>
