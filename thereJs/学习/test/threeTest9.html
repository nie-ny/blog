<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>å­¦ä¹ </title>
  </head>
  <body>
    <canvas id="c2d" class="c2d" width="1000" height="500"></canvas>
    <script type="module">
      /**
       * ç»˜åˆ¶3Dåœ°çƒ
       * */
      import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/build/three.module.js'
      import * as BufferGeometryUtils from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/utils/BufferGeometryUtils.js'
      import { OrbitControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/controls/OrbitControls.js'

      const canvas = document.querySelector('#c2d')
      // æ¸²æŸ“å™¨
      const renderer = new THREE.WebGLRenderer({ canvas })

      const fov = 60
      const aspect = 2 // the canvas default
      const near = 0.1
      const far = 10
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
      camera.position.z = 2.5

      const controls = new OrbitControls(camera, canvas)
      controls.enableDamping = true
      controls.enablePan = false
      // è®¾ç½®ç›¸æœºè·ç¦»åŸç‚¹çš„æœ€è¿œè·ç¦»
      controls.minDistance = 1.2
      controls.maxDistance = 4
      controls.update()

      const scene = new THREE.Scene()
      scene.background = new THREE.Color('black')

      {
        const loader = new THREE.TextureLoader()
        const texture = loader.load('https://threejsfundamentals.org/threejs/resources/images/world.jpg', render)
        const geometry = new THREE.SphereGeometry(1, 64, 32)
        const material = new THREE.MeshBasicMaterial({ map: texture })
        scene.add(new THREE.Mesh(geometry, material))
      }

      async function loadFile(url) {
        const req = await fetch(url)
        return req.text()
      }

      function parseData(val) {
        const data = []
        const settings = { data }
        let max
        let min
        val.split('\n').forEach((line) => {
          // æ ¹æ®ç©ºæ ¼åˆ†éš”
          const parts = line.trim().split(/\s+/)
          if (parts.length === 2) {
            // é•¿åº¦ä¸º2çš„å¿…å®šæ˜¯é”®å€¼å¯¹
            settings[parts[0]] = parseFloat(parts[1])
          } else if (parts.length > 2) {
            // é•¿åº¦è¶…è¿‡2çš„è‚¯å®šæ˜¯ç½‘æ ¼æ•°æ®
            const values = parts.map((v) => {
              const value = parseFloat(v)
              if (value === settings.NODATA_value) {
                return undefined
              }
              max = Math.max(max === undefined ? value : max, value)
              min = Math.min(min === undefined ? value : min, value)
              return value
            })
            data.push(values)
          }
        })
        return Object.assign(settings, { min, max })
      }
      // æ ¹æ®æ•°æ® ç»˜åˆ¶æ–¹æ ¼
      function addBoxes(file) {
        console.log('ğŸš€ ~ file: threeTest9.html ~ line 80 ~ addBoxes ~ file', file)
        const { min, max, data } = file
        const range = max - min

        // // æ–°å»ºä¸€ä¸ªbox geometry
        // const boxWidth = 1
        // const boxHeight = 1
        // const boxDepth = 1
        // const geometry = new THREE.BoxBufferGeometry(boxWidth, boxHeight, boxDepth)
        // // æ²¿ç€zè½´ç¼©æ”¾
        // geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0, 0.5))

        // ä½ç½®è¾…åŠ©å™¨å¯ä»¥æ–¹ä¾¿åœ°åœ¨çƒé¢ä¸Šå®šä½
        // ç»åº¦è¾…åŠ©å™¨å¯ä»¥åœ¨XZå¹³é¢çš„æ³•å‘æ—‹è½¬
        const lonHelper = new THREE.Object3D()
        scene.add(lonHelper)
        // çº¬åº¦è¾…åŠ©å™¨å¯ä»¥åœ¨XZå¹³é¢æ—‹è½¬
        const latHelper = new THREE.Object3D()
        lonHelper.add(latHelper)
        // ç»„åˆèµ·æ¥å¾—åˆ°çš„ä½ç½®è¾…åŠ©å™¨å¯ä»¥åœ¨çƒé¢ä¸Šå®šä½
        const positionHelper = new THREE.Object3D()
        positionHelper.position.z = 1
        latHelper.add(positionHelper)
        // ç”¨æ¥å®šä½ç›’å­çš„ä¸­å¿ƒ, ä»¥ä¾¿æ¥ä¸‹æ¥æ²¿ç€Zè½´ç¼©æ”¾
        const originHelper = new THREE.Object3D()
        originHelper.position.z = 0.5
        positionHelper.add(originHelper)

        // lonFudgeæ˜¯Ï€/2ä¹Ÿå°±æ˜¯å››åˆ†ä¹‹ä¸€åœˆ, ä¹Ÿå°±æ˜¯è¯´åœ¨åœ¨ä¸€å‘¨ä¸Šæ˜¯ä»¥ä¸åŒçš„åç§»å¼€å§‹
        const lonFudge = Math.PI * 0.5
        // latFudge è¦ä¹˜ä»¥ä¸ª Ï€ * -0.135, ä¼¼ä¹å°±æ˜¯ä¸€ä¸ªèƒ½è®©ç›’å­å’Œæè´¨å¯¹é½çš„æ•°
        const latFudge = Math.PI * -0.135

        // ç›’å­å‡ ä½• é›†åˆ
        const geometries = []
        // å¤„ç†äºŒç»´æ•°ç»„æ•°æ®
        data.forEach((row, latNdx) => {
          row.forEach((value, lonNdx) => {
            //
            if (value === undefined) {
              return
            }
            const amount = (value - min) / range

            // // è®¾ç½®æè´¨ æ ¹æ® æ•°æ®å¤§å° è®¾ç½®é¢œè‰²
            // const material = new THREE.MeshBasicMaterial()
            // // è¿”å›åŒºé—´ç±»çš„ çº¿æ€§å€¼
            // const hue = THREE.MathUtils.lerp(0.7, 0.3, amount)
            // const saturation = 1
            // const lightness = THREE.MathUtils.lerp(0.4, 1.0, amount)
            // material.color.setHSL(hue, saturation, lightness)
            // // æ·»åŠ æ¨¡å‹
            // const mesh = new THREE.Mesh(geometry, material)
            // scene.add(mesh)
            const boxWidth = 1
            const boxHeight = 1
            const boxDepth = 1
            const geometry = new THREE.BoxBufferGeometry(boxWidth, boxHeight, boxDepth)

            /**
             * ä½¿ç”¨ ä½ç½®è¾…åŠ©å™¨ ä¿®æ”¹æ¨¡å‹ åœ¨çƒé¢ä½ç½®
             * */
            // è°ƒæ•´è¾…åŠ©å™¨ä½¿å…¶æŒ‡å‘ç»çº¬åº¦ MathUtils.degToRadè½¬åŒ–å¼§åº¦
            lonHelper.rotation.y = THREE.MathUtils.degToRad(lonNdx + file.xllcorner) + lonFudge
            latHelper.rotation.x = THREE.MathUtils.degToRad(latNdx + file.yllcorner) + latFudge

            // // ä½¿ç”¨world matrixæ¥æ“ä½œè¾…åŠ©å™¨
            // positionHelper.updateWorldMatrix(true, false)
            // mesh.applyMatrix4(positionHelper.matrixWorld)
            // // ç¼©å°æ–¹æ ¼
            // mesh.scale.set(0.005, 0.005, THREE.MathUtils.lerp(0.01, 0.5, amount))

            // ä½¿ç”¨ä½ç½®è¾…åŠ©å™¨å’Œworld matrix æ¥å®šä½
            positionHelper.scale.set(0.005, 0.005, THREE.MathUtils.lerp(0.01, 0.5, amount))
            originHelper.updateWorldMatrix(true, false)
            geometry.applyMatrix4(originHelper.matrixWorld)

            geometries.push(geometry)
          })
        })

        const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries, false)
        const material = new THREE.MeshBasicMaterial({ color: 'red' })
        const mesh = new THREE.Mesh(mergedGeometry, material)
        scene.add(mesh)
      }

      loadFile(
        'https://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc'
      )
        .then(parseData)
        .then(addBoxes)
        .then(render)

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement
        const width = canvas.clientWidth
        const height = canvas.clientHeight
        const needResize = canvas.width !== width || canvas.height !== height
        if (needResize) {
          renderer.setSize(width, height, false)
        }
        return needResize
      }

      // æ§åˆ¶ é‡å¤æ‰§è¡Œ
      let renderRequested = false
      function render() {
        renderRequested = undefined

        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement
          camera.aspect = canvas.clientWidth / canvas.clientHeight
          camera.updateProjectionMatrix()
        }

        controls.update()
        renderer.render(scene, camera)
      }
      render()

      function requestRenderIfNotRequested() {
        if (!renderRequested) {
          renderRequested = true
          requestAnimationFrame(render)
        }
      }

      // ç›¸æœºä½ç½®ä¿®æ”¹ é‡æ–°ç»˜åˆ¶
      controls.addEventListener('change', requestRenderIfNotRequested)
      window.addEventListener('resize', requestRenderIfNotRequested)
    </script>
  </body>
</html>
