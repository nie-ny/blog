<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <canvas id="c2d" class="c2d" width="390" height="290"></canvas>
    <script type="text/javascript">
      /**
       * ç”Ÿæˆ è¿·å®«
       * */
      var oC2 = document.getElementById('c2d')
      var ctx = oC2.getContext('2d')

      // èŽ·å–å®½é«˜
      var width = oC2.width
      var height = oC2.height

      var maxX = 18 // è·¯çš„ åˆ—æ•°
      var maxY = 13 // è·¯çš„ è¡Œæ•°

      var firstGrid // å¼€å§‹ç‚¹
      var endGrid // ç»“æŸç‚¹

      /**
       * åˆ›å»ºæ ¼
       */
      function Grid(x, y) {
        this.x = x
        this.y = y
        this.choosed = false // æ˜¯å¦æ ‡è®°
        this.children = []
        this.initNeighbor()
      }

      // èŽ·å–å½“å‰æ ¼ å¯¹åº”çš„é‚»æ ¼
      Grid.prototype.initNeighbor = function () {
        var x = this.x
        var y = this.y

        this.neighbor = []

        if (y > 0) {
          this.neighbor.push({
            x: x,
            y: y - 1
          })
        }

        if (y < maxY) {
          this.neighbor.push({
            x: x,
            y: y + 1
          })
        }

        if (x > 0) {
          this.neighbor.push({
            x: x - 1,
            y: y
          })
        }

        if (x < maxX) {
          this.neighbor.push({
            x: x + 1,
            y: y
          })
        }

        // éšæœºæŽ’åº
        this.neighbor.sort(function () {
          return 0.5 - Math.random()
        })
      }

      // èŽ·å– é‚»æ ¼ å¹¶è®¾ç½® å½“å‰æ ¼ä¸ºçˆ¶çº§ -- è¿›å…¥å°±ä¼šæ ‡è®° ä¿è¯ æ ¼å­ å­å…³è”ä¸€æ¬¡
      Grid.prototype.getNeighbor = function () {
        var x, y, neighbor
        // æ ‡è®°æ ¼
        this.choosed = true
        // console.log("ðŸš€ ~ file: mi.html ~ line 82 ~ this", this);

        for (var i = 0; i < this.neighbor.length; i++) {
          x = this.neighbor[i].x
          y = this.neighbor[i].y

          // è¿·å®« å¯¹åº”ä½ç½®çš„ç™½è‰²æ ¼å­
          neighbor = maze.grids[y][x]

          // å½“æ ¼å­æœªæ ‡è®° è¿”å›žå½“å‰æ ¼å­ å¹¶è®¾ç½®parentä¸º æ“ä½œçš„æ ¼å­
          if (!neighbor.choosed) {
            neighbor.parent = this
            return neighbor
          }
        }

        //
        if (this.parent === firstGrid) {
          return 0
        } else {
          return 1
        }
      }

      /**
       * è¿·å®«å®žä¾‹
       */
      function Maze() {
        this.path = []
        this.grids = [] // æ ¼å­
        this.stack = []
        this.init()
      }
      /**
       * ç»„è£… æ•´ä¸ªè¿·å®« ç™½è‰²æ ¼å­æ•°æ®
       */
      Maze.prototype.init = function () {
        for (var i = 0; i <= maxY; i++) {
          this.grids[i] = []
          for (var j = 0; j <= maxX; j++) {
            this.grids[i][j] = new Grid(j, i)
          }
        }
        firstGrid = this.grids[0][0] // å¼€å§‹æ ¼
        endGrid = this.grids[13][18] // ç»“æŸæ ¼
      }
      /**
       * å¼€å§‹å¯»æ‰¾è·¯å¾„
       */
      Maze.prototype.findPath = function () {
        var tmp
        // å¾—åˆ°ç¬¬ä¸€æ ¼
        var curr = firstGrid

        while (1) {
          tmp = curr.getNeighbor()

          if (tmp === 0) {
            console.log('è·¯å¾„æ‰¾å¯»ç»“æŸ')
            break
          } else if (tmp === 1) {
            // å½“é‚»æ ¼ éƒ½æ ‡è®°äº† æ“ä½œçˆ¶çº§
            curr = curr.parent
          } else {
            // è¿”å›žçš„ ç›¸é‚»æ ¼å­ è®¾ç½®ä¸º children å½¢æˆæ ‘
            curr.children[curr.children.length] = tmp
            curr = tmp
          }
        }
      }

      // å¾ªçŽ¯ç»˜åˆ¶ è·¯
      function drawPath(node) {
        // console.log("ðŸš€ ~ file: mi.html ~ line 154 ~ drawPath ~ node", node);
        var i = 0
        // ç»˜åˆ¶ é‚»æ ¼
        drawRect(node.x * 20, node.y * 20)

        for (; i < node.children.length; i++) {
          if (node.children[i]) {
            // é‚»æ ¼ ä¸­é—´æ‰“é€š
            drawRect(node.x * 20 + (node.children[i].x - node.x) * 10, node.y * 20 + (node.children[i].y - node.y) * 10)
            // ç”»è·¯
            drawPath(node.children[i])
          }
        }
      }
      /**
       * ç»˜åˆ¶æ–¹æ ¼
       */
      function drawRect(x, y) {
        // + 10 ä»Žå†…æ¡†å¼€å§‹ç”»
        ctx.fillRect(x + 10, y + 10, 10, 10)
      }
      // function drawDebug(x, y, color) {
      //   // å¼€å§‹ä¸€æ¡è·¯å¾„
      //   ctx.beginPath();
      //   ctx.fillStyle = color;
      //   // åˆ›å»ºå¼§/æ›²çº¿
      //   ctx.arc(x, y, 1, 0, Math.PI * 2, false);
      //   // å¡«å……å½“å‰ç»˜å›¾
      //   ctx.fill();
      //   // åˆ›å»ºä»Žå½“å‰ç‚¹å›žåˆ°èµ·å§‹ç‚¹çš„è·¯å¾„
      //   ctx.closePath();
      // }
      // ç»˜åˆ¶è¿·å®«èƒŒæ™¯ é»‘è‰²
      ctx.fillStyle = 'black'
      ctx.fillRect(0, 0, width, height)
      ctx.fillStyle = 'white'

      var maze = new Maze()

      maze.findPath()

      drawPath(firstGrid)

      // å¼€å§‹ ç»“æŸæ–¹æ ¼ ç”»ä¸Š
      drawStartEnd()
      function drawStartEnd() {
        ctx.fillRect(0, 10, 10, 10)
        ctx.fillRect(19 * 20, 13 * 20 + 10, 10, 10)
      }
    </script>
  </body>
</html>
